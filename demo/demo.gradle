import com.bmuschko.gradle.docker.tasks.image.DockerPushImage
import com.bmuschko.gradle.docker.tasks.image.DockerRemoveImage
import com.bmuschko.gradle.docker.tasks.image.DockerTagImage

plugins {
    id 'java'
    id 'application'
    id 'io.quarkus'
    id 'io.deephaven.project.register'
    id 'com.bmuschko.docker-remote-api'
}

evaluationDependsOn ':demo-server'
evaluationDependsOn ':demo-web'
java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(11)
    }
}

application {
    mainClassName = 'io.deephaven.demo.DhDemoServer'
}

run {
    environment("IS_CONTROLLER", System.getenv("IS_CONTROLLER") ?: "true")
    environment("COOKIE_DOMAIN", "localhost")
    environment("ALLOW_ADDRESS_LOOKUP", "false")
}

// we use withType(JavaExec) to catch intellij-created run configurations
tasks.withType(JavaExec).configureEach {
    JavaExec exe ->
        // see https://vertx.io/docs/vertx-web/java/
        // setting this here ensures local gradle runs won't cache things,
        // but running in a production container (not a gradle JavaExec), we let it cache
        exe.systemProperty("vertxweb.environment", "dev")
        exe.systemProperty("dh-helm-root", new File(projectDir, "helm").absolutePath)
        exe.systemProperty("dh-helm-mode", "generate")
        exe.systemProperty("dh-helm-target", new File(buildDir, "helm").absolutePath)
        exe.environment("IS_CONTROLLER", System.getenv("IS_CONTROLLER") ?: "true")
}

dependencies {
    implementation project(':Base')

    String quarkusGroup = findProperty('quarkusPlatformGroupId')
    String quarkusArtifact = findProperty('quarkusPlatformArtifactId')
    String quarkusVersion = findProperty('quarkusPlatformVersion')
    implementation enforcedPlatform("${quarkusGroup}:${quarkusArtifact}:${quarkusVersion}")
    implementation enforcedPlatform("${quarkusGroup}:quarkus-google-cloud-services-bom:${quarkusVersion}")

    // The tools we will use to build our controller
    implementation 'io.quarkus:quarkus-vertx-http'
   // implementation 'io.quarkus:quarkus-resteasy-reactive-jackson'
    implementation 'io.smallrye.reactive:smallrye-mutiny-vertx-web-client'

    implementation 'com.squareup.okhttp3:okhttp'
    implementation 'com.google.guava:guava'
    implementation 'commons-io:commons-io'

    runtime "io.netty:netty-transport-native-epoll:$quarkusVersion:linux-x86_64"
    runtime "io.netty:netty-transport-native-kqueue:$quarkusVersion:osx-x86_64"

    testImplementation 'io.quarkus:quarkus-junit5'
    testImplementation 'io.rest-assured:rest-assured'
    testImplementation "junit:junit:4.13.2'"
}

test {
    useJUnit()
    // uncomment below to leave test machine alive to play with
    // systemProperty("noClean", "true") // WIP: must comment whole line to merge
}

String launchScript = 'launchScript'
tasks.register(launchScript).configure{
    Task t ->
        final String startScript = """#!/bin/bash
test -f /certs/deephaven-svc-act.json && gcloud auth activate-service-account --key-file=/certs/deephaven-svc-act.json
gcloud config set core/disable_usage_reporting true
gcloud config set component_manager/disable_update_check true
gcloud config set project deephaven-oss
export JAVA_OPTIONS="-Dquarkus.log.level=DEBUG -Dquarkus.http.host=0.0.0.0 -Dquarkus.http.port=7117 -Djava.util.logging.manager=org.jboss.logmanager.LogManager"
cd /deployments
./run-java.sh --debug
"""
        File protoOut = new File(buildDir, launchScript)
        t.outputs.dir(protoOut)
        t.inputs.property("startScript", startScript)
        t.doLast {
            protoOut.mkdirs()
            File demoStart = new File(protoOut, 'demo-start.sh')
            demoStart.text = startScript
            demoStart.setExecutable(true, false)
        }

}

String protoSyncName = 'protoSync'
tasks.register(protoSyncName, Sync).configure{
    Sync t ->
        File protoOut = new File(buildDir, protoSyncName)
        t.destinationDir(protoOut)
        gradle.rootProject.allprojects*.projectDir.forEach {
            File f ->
                File protos = new File(f, 'src/main/proto')
                protos.directory && t.from(protos)
        }
}


// we don't want to get a manually-deployed machine confused with a controller-issued "customer" machine,
// so we're going to append the git branch name to the worker's version.
String machineVersion = findProperty('version')

// if an explicit hostname is specified, only consider explicit -Pversion if it doesn't match gradle project version.
// this is to prevent running controllers from trying to manage and share developer-created machines.
if (findProperty('hostname')) {
    if (!machineVersion || machineVersion == version) {
        // if user does not specify custom -Pversion= flag, we'll make sure to prefix with, by default, sanitized git branch name
        String versionSuffix = findProperty('versionSuffix') ?: System.getenv('BRANCH_NAME') ?: [ 'git', 'rev-parse', '--abbrev-ref', 'HEAD' ].execute().text.trim() ?: machineName

        // replace any non-alphanumeric characters w/ -
        versionSuffix = versionSuffix.replaceAll("[^\\p{Alnum}]", "-").replaceAll("[-]+", "-")
        // hmm... this needs to permeate all the way back to image deployment versions...
        machineVersion = version + "_" + versionSuffix
        project.ext.set 'quarkus.application.version', machineVersion
//        System.setProperty 'quarkus.application.version', machineVersion
    }
}

// TODO: forcibly test that a few toolchains can compile + run our code...
quarkusBuild {
    // don't realize the task just to put this dependsOn in place
    dependsOn "$project.path:$protoSyncName", "$project.path:$launchScript"
    inputs.property('machineVersion', machineVersion)

    nativeArgs {
        containerBuild = true
        buildImage = "quay.io/quarkus/ubi-quarkus-native-image:21.1.0-java11"
    }
}

String grpcApiRepository = project.property('grpcApiRepository')
String grpcApiTag = machineVersion

String webRepository = project.property('webRepository')
String webTag = machineVersion

def tagDemoWorkerTask = tasks.register('tagDemoWorker', DockerTagImage) {
    DockerTagImage t ->
        def demoGrpcApi = project(':demo-server')
        t.imageId.set demoGrpcApi.property('image') as String
        t.repository.set grpcApiRepository
        t.tag.set grpcApiTag
        t.force.set true
        t.dependsOn demoGrpcApi.tasks.findByName('buildImage')
}

def tagWebTask = tasks.register('tagWeb', DockerTagImage) {
    DockerTagImage t ->
        def demoWeb = project(':demo-web')
        t.imageId.set demoWeb.property('image') as String
        t.repository.set webRepository
        t.tag.set webTag
        t.force.set true
        t.dependsOn demoWeb.tasks.findByName('buildImage')
}

def tagAll = tasks.register('tagAll') {
    it.dependsOn tagDemoWorkerTask, tagWebTask
}

def untagDemoWorker = tasks.register('untagDemoWorker', DockerRemoveImage) {
    it.imageId.set "${grpcApiRepository}:${grpcApiTag}"
    it.onError { exception ->
        if (!exception.message.contains('No such image'))
            throw exception
    }
}

def untagWeb = tasks.register('untagWeb', DockerRemoveImage) {
    it.imageId.set "${webRepository}:${webTag}"
    it.onError { exception ->
        if (!exception.message.contains('No such image'))
            throw exception
    }
}

tasks.register('cleanDocker') {
    it.dependsOn untagDemoWorker, untagWeb
}

def pushAllTask = tasks.register('pushAll', DockerPushImage) {
    DockerPushImage p ->
        p.images.set([
                "${grpcApiRepository}:${grpcApiTag}",
                "${webRepository}:${webTag}",
        ] as Set)
        p.dependsOn tagAll
}

tasks.register('deployDemo', JavaExec) {
    JavaExec exe ->
        exe.dependsOn(pushAllTask, 'quarkusBuild')
        exe.main('io.deephaven.demo.deploy.ImageDeployer')
        exe.classpath(sourceSets.main.runtimeClasspath)
        exe.systemProperty('deployImage', 'true')
        exe.systemProperty('useImages', 'true')
        exe.systemProperty('dh-version', version)
        // workerOnly for deployDemo defaults to false, so we check for explicit true conditions only:
        exe.systemProperty('workerOnly', "true" == findProperty('workerOnly') || "1" == findProperty("wO"))
        exe.systemProperty('force', "true" == findProperty('force'))
}

tasks.register('deployMachine', JavaExec) {
    JavaExec exe ->
        exe.dependsOn(pushAllTask, 'quarkusBuild')
        String machineName = findProperty("hostname")
        if (!machineName) {
            throw new IllegalStateException("Cannot run $exe.path without passing -Phostname=my-machine-name")
        }
        exe.main('io.deephaven.demo.deploy.ImageDeployer')
        exe.args("--worker", machineName)
        exe.classpath(sourceSets.main.runtimeClasspath)
        exe.systemProperty('rebuildWorker', 'true') // for now, we have to rebuild for image changes to get picked up!
        exe.systemProperty('deployImage', 'false')
        // workerOnly for deployMachine defaults to true, so we check for explicit false conditions only:
        exe.systemProperty('workerOnly', "false" == findProperty('workerOnly') || "0" == findProperty("wO"))
        exe.systemProperty('force', "true" == findProperty('force'))

        exe.systemProperty('dh-version', machineVersion)
        // we still want to use our base image snapshot... if it exists...
        exe.systemProperty('DH_SNAPSHOT_NAME', "deephaven-app-${version.replaceAll("[.]", "-")}")
        exe.systemProperty('useImages', 'false')
        logger.quiet "Setting machine {} to use version {}", machineName, machineVersion
}

Task quark = tasks.getByName('quarkusBuild')
quark.finalizedBy {
    // check for error state,
    if (quark.state.failure) {
        logger.quiet("This task can fail if you have not recently authorized docker with gcloud")
        logger.quiet("To do so:\n" +
                "ZONE=us-central1\n" +
                "REPO_ROOT=\"\${ZONE}-docker.pkg.dev\"\n" +
                "gcloud auth configure-docker \"\$REPO_ROOT\"")
    }
}
